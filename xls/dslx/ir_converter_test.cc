// Copyright 2021 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Tests that explicit check the IR output generated by various DSL constructs.
//
// This amounts to whitebox testing of the IR converter end-to-end, whereas DSLX
// tests (i.e. in dslx/tests) are testing functional correctness of results
// (which is more blackbox with respect to the IR conversion process).

#include "xls/dslx/ir_converter.h"

#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "absl/flags/flag.h"
#include "xls/common/file/filesystem.h"
#include "xls/common/file/get_runfile_path.h"
#include "xls/common/init_xls.h"
#include "xls/common/status/matchers.h"
#include "xls/common/update_golden_files.inc"
#include "xls/dslx/parse_and_typecheck.h"

ABSL_FLAG(std::string, xls_source_dir, "",
          "Absolute path to root of XLS source directory to modify when "
          "--test_update_golden_files is given");

namespace xls::dslx {
namespace {

void ExpectIr(absl::string_view got, absl::string_view test_name) {
  std::string suffix =
      absl::StrCat("dslx/testdata/ir_converter_test_", test_name, ".ir");
  if (absl::GetFlag(FLAGS_test_update_golden_files)) {
    std::string path =
        absl::StrCat(absl::GetFlag(FLAGS_xls_source_dir), "/", suffix);
    XLS_ASSERT_OK(SetFileContents(path, got));
    return;
  }
  XLS_ASSERT_OK_AND_ASSIGN(std::filesystem::path runfile,
                           GetXlsRunfilePath(absl::StrCat("xls/", suffix)));
  XLS_ASSERT_OK_AND_ASSIGN(std::string want, GetFileContents(runfile));
  EXPECT_EQ(got, want);
}

std::string TestName() {
  return ::testing::UnitTest::GetInstance()->current_test_info()->name();
}

absl::StatusOr<std::string> ConvertOneFunctionForTest(
    absl::string_view program, absl::string_view fn_name,
    bool emit_positions = true) {
  ImportCache import_cache;
  XLS_ASSIGN_OR_RETURN(TypecheckedModule tm,
                       ParseAndTypecheck(program, /*path=*/"test_module.x",
                                         /*module_name=*/"test_module",
                                         /*import_cache=*/&import_cache));
  return ConvertOneFunction(tm.module, fn_name, tm.type_info,
                            /*symbolic_bindings=*/nullptr,
                            /*emit_positions=*/emit_positions);
}

absl::StatusOr<std::string> ConvertModuleForTest(
    absl::string_view program, bool emit_positions = true,
    ImportCache* import_cache = nullptr) {
  absl::optional<ImportCache> import_cache_value;
  if (import_cache == nullptr) {
    import_cache_value.emplace();
    import_cache = &*import_cache_value;
  }
  XLS_ASSIGN_OR_RETURN(
      TypecheckedModule tm,
      ParseAndTypecheck(program, "test_module.x", "test_module", import_cache));
  XLS_ASSIGN_OR_RETURN(std::string converted,
                       ConvertModule(tm.module, tm.type_info,
                                     /*emit_positions=*/emit_positions));
  return converted;
}

TEST(IrConverterTest, Concat) {
  const char* program =
      R"(fn f(x: bits[31]) -> u32 {
  bits[1]:1 ++ x
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(std::string converted,
                           ConvertOneFunctionForTest(program, "f"));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f(x: bits[31]) -> bits[32] {
  literal.2: bits[1] = literal(value=1, id=2, pos=0,1,10)
  ret concat.3: bits[32] = concat(literal.2, x, id=3, pos=0,1,12)
}
)");
}

TEST(IrConverterTest, TwoPlusTwo) {
  const char* program =
      R"(fn two_plus_two() -> u32 {
  u32:2 + u32:2
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(std::string converted,
                           ConvertOneFunctionForTest(program, "two_plus_two"));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__two_plus_two() -> bits[32] {
  literal.1: bits[32] = literal(value=2, id=1, pos=0,1,6)
  literal.2: bits[32] = literal(value=2, id=2, pos=0,1,14)
  ret add.3: bits[32] = add(literal.1, literal.2, id=3, pos=0,1,8)
}
)");
}

TEST(IrConverterTest, NegativeX) {
  const char* program =
      R"(fn negate(x: u32) -> u32 {
  -x
})";
  XLS_ASSERT_OK_AND_ASSIGN(std::string converted,
                           ConvertOneFunctionForTest(program, "negate"));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__negate(x: bits[32]) -> bits[32] {
  ret neg.2: bits[32] = neg(x, id=2, pos=0,1,2)
}
)");
}

TEST(IrConverterTest, LetBinding) {
  const char* program =
      R"(fn f() -> u32 {
  let x: u32 = u32:2;
  x+x
})";
  XLS_ASSERT_OK_AND_ASSIGN(std::string converted,
                           ConvertOneFunctionForTest(program, "f"));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f() -> bits[32] {
  literal.1: bits[32] = literal(value=2, id=1, pos=0,1,19)
  ret add.2: bits[32] = add(literal.1, literal.1, id=2, pos=0,2,3)
}
)");
}

TEST(IrConverterTest, LetTupleBinding) {
  const char* program =
      R"(fn f() -> u32 {
  let t = (u32:2, u32:3);
  let (x, y) = t;
  x+y
})";
  XLS_ASSERT_OK_AND_ASSIGN(std::string converted,
                           ConvertOneFunctionForTest(program, "f"));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f() -> bits[32] {
  literal.1: bits[32] = literal(value=2, id=1, pos=0,1,15)
  literal.2: bits[32] = literal(value=3, id=2, pos=0,1,22)
  t: (bits[32], bits[32]) = tuple(literal.1, literal.2, id=3, pos=0,1,10)
  x: bits[32] = tuple_index(t, index=0, id=4, pos=0,2,7)
  y: bits[32] = tuple_index(t, index=1, id=5, pos=0,2,10)
  ret add.6: bits[32] = add(x, y, id=6, pos=0,3,3)
}
)");
}

TEST(IrConverterTest, LetTupleBindingNested) {
  const char* program =
      R"(fn f() -> u32 {
  let t = (u32:2, (u32:3, (u32:4,), u32:5));
  let (x, (y, (z,), a)) = t;
  x+y+z+a
})";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertOneFunctionForTest(program, "f", /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f() -> bits[32] {
  literal.3: bits[32] = literal(value=4, id=3)
  literal.2: bits[32] = literal(value=3, id=2)
  tuple.4: (bits[32]) = tuple(literal.3, id=4)
  literal.5: bits[32] = literal(value=5, id=5)
  literal.1: bits[32] = literal(value=2, id=1)
  tuple.6: (bits[32], (bits[32]), bits[32]) = tuple(literal.2, tuple.4, literal.5, id=6)
  t: (bits[32], (bits[32], (bits[32]), bits[32])) = tuple(literal.1, tuple.6, id=7)
  tuple_index.9: (bits[32], (bits[32]), bits[32]) = tuple_index(t, index=1, id=9)
  x: bits[32] = tuple_index(t, index=0, id=8)
  y: bits[32] = tuple_index(tuple_index.9, index=0, id=10)
  tuple_index.11: (bits[32]) = tuple_index(tuple_index.9, index=1, id=11)
  add.14: bits[32] = add(x, y, id=14)
  z: bits[32] = tuple_index(tuple_index.11, index=0, id=12)
  add.15: bits[32] = add(add.14, z, id=15)
  a: bits[32] = tuple_index(tuple_index.9, index=2, id=13)
  ret add.16: bits[32] = add(add.15, a, id=16)
}
)");
}

TEST(IrConverterTest, Struct) {
  const char* program =
      R"(struct S {
  zub: u8,
  qux: u8,
}

fn f(a: S, b: S) -> u8 {
  let foo = a.zub + b.qux;
  (S { zub: u8:42, qux: u8:0 }).zub + (S { zub: u8:22, qux: u8:11 }).zub
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertOneFunctionForTest(program, "f", /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f(a: (bits[8], bits[8]), b: (bits[8], bits[8])) -> bits[8] {
  literal.6: bits[8] = literal(value=42, id=6)
  literal.7: bits[8] = literal(value=0, id=7)
  literal.10: bits[8] = literal(value=22, id=10)
  literal.11: bits[8] = literal(value=11, id=11)
  tuple.8: (bits[8], bits[8]) = tuple(literal.6, literal.7, id=8)
  tuple.12: (bits[8], bits[8]) = tuple(literal.10, literal.11, id=12)
  a_zub: bits[8] = tuple_index(a, index=0, id=3)
  b_qux: bits[8] = tuple_index(b, index=1, id=4)
  zub: bits[8] = tuple_index(tuple.8, index=0, id=9)
  zub__1: bits[8] = tuple_index(tuple.12, index=0, id=13)
  foo: bits[8] = add(a_zub, b_qux, id=5)
  ret add.14: bits[8] = add(zub, zub__1, id=14)
}
)");
}

TEST(IrConverterTest, Index) {
  const char* program =
      R"(fn f(x: uN[32][4]) -> u32 {
  x[u32:0]
})";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertOneFunctionForTest(program, "f", /*emit_positions=*/true));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f(x: bits[32][4]) -> bits[32] {
  literal.2: bits[32] = literal(value=0, id=2, pos=0,1,8)
  ret array_index.3: bits[32] = array_index(x, indices=[literal.2], id=3, pos=0,1,3)
}
)");
}

TEST(IrConverterTest, TupleOfParameters) {
  const char* program =
      R"(fn f(x: u8, y: u8) -> (u8, u8) {
  (x, y)
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertOneFunctionForTest(program, "f", /*emit_positions=*/true));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f(x: bits[8], y: bits[8]) -> (bits[8], bits[8]) {
  ret tuple.3: (bits[8], bits[8]) = tuple(x, y, id=3, pos=0,1,2)
}
)");
}

TEST(IrConverterTest, TupleOfLiterals) {
  const char* program =
      R"(fn f() -> (u8, u8) {
  (u8:0xaa, u8:0x55)
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertOneFunctionForTest(program, "f", /*emit_positions=*/true));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f() -> (bits[8], bits[8]) {
  literal.1: bits[8] = literal(value=170, id=1, pos=0,1,6)
  literal.2: bits[8] = literal(value=85, id=2, pos=0,1,15)
  ret tuple.3: (bits[8], bits[8]) = tuple(literal.1, literal.2, id=3, pos=0,1,2)
}
)");
}

TEST(IrConverterTest, CountedFor) {
  const char* program =
      R"(fn f() -> u32 {
  for (i, accum): (u32, u32) in range(u32:0, u32:4) {
    accum + i
  }(u32:0)
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertOneFunctionForTest(program, "f", /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn ____test_module__f_counted_for_0_body(i: bits[32], accum: bits[32]) -> bits[32] {
  ret add.6: bits[32] = add(accum, i, id=6)
}

fn __test_module__f() -> bits[32] {
  literal.1: bits[32] = literal(value=0, id=1)
  literal.2: bits[32] = literal(value=0, id=2)
  literal.3: bits[32] = literal(value=4, id=3)
  ret counted_for.7: bits[32] = counted_for(literal.1, trip_count=4, stride=1, body=____test_module__f_counted_for_0_body, id=7)
}
)");
}

TEST(IrConverterTest, CountedForDestructuring) {
  const char* program =
      R"(fn f() -> u32 {
  let t = for (i, (x, y)): (u32, (u32, u8)) in range(u32:0, u32:4) {
    (x + i, y)
  }((u32:0, u8:0));
  t[0]
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertOneFunctionForTest(program, "f", /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn ____test_module__f_counted_for_0_body(i: bits[32], __loop_carry: (bits[32], bits[8])) -> (bits[32], bits[8]) {
  literal.8: bits[1] = literal(value=1, id=8)
  literal.10: bits[1] = literal(value=1, id=10)
  tuple_index.9: bits[32] = tuple_index(__loop_carry, index=0, id=9)
  and.11: bits[1] = and(literal.8, literal.10, id=11)
  literal.13: bits[1] = literal(value=1, id=13)
  add.15: bits[32] = add(tuple_index.9, i, id=15)
  tuple_index.12: bits[8] = tuple_index(__loop_carry, index=1, id=12)
  and.14: bits[1] = and(and.11, literal.13, id=14)
  ret tuple.16: (bits[32], bits[8]) = tuple(add.15, tuple_index.12, id=16)
}

fn __test_module__f() -> bits[32] {
  literal.1: bits[32] = literal(value=0, id=1)
  literal.2: bits[8] = literal(value=0, id=2)
  tuple.3: (bits[32], bits[8]) = tuple(literal.1, literal.2, id=3)
  t: (bits[32], bits[8]) = counted_for(tuple.3, trip_count=4, stride=1, body=____test_module__f_counted_for_0_body, id=17)
  literal.4: bits[32] = literal(value=0, id=4)
  literal.5: bits[32] = literal(value=4, id=5)
  literal.18: bits[32] = literal(value=0, id=18)
  ret tuple_index.19: bits[32] = tuple_index(t, index=0, id=19)
}
)");
}

TEST(IrConverterTest, CountedForParametricConst) {
  const char* program =
      R"(fn f<N: u32>(x: bits[N]) -> u32 {
  for (i, accum): (u32, u32) in range(u32:0, N) {
    accum + i
  }(u32:0)
}
fn main() -> u32 {
  f(bits[2]:0)
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  ExpectIr(converted, TestName());
}

TEST(IrConverterTest, CountedForInvokingFunctionFromBody) {
  const char* program =
      R"(fn my_id(x: u32) -> u32 { x }
fn f() -> u32 {
  for (i, accum): (u32, u32) in range(u32:0, u32:4) {
    my_id(accum + i)
  }(u32:0)
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__my_id(x: bits[32]) -> bits[32] {
  ret identity.2: bits[32] = identity(x, id=2)
}

fn ____test_module__f_counted_for_0_body(i: bits[32], accum: bits[32]) -> bits[32] {
  add.8: bits[32] = add(accum, i, id=8)
  ret invoke.9: bits[32] = invoke(add.8, to_apply=__test_module__my_id, id=9)
}

fn __test_module__f() -> bits[32] {
  literal.3: bits[32] = literal(value=0, id=3)
  literal.4: bits[32] = literal(value=0, id=4)
  literal.5: bits[32] = literal(value=4, id=5)
  ret counted_for.10: bits[32] = counted_for(literal.3, trip_count=4, stride=1, body=____test_module__f_counted_for_0_body, id=10)
}
)");
}

TEST(IrConverterTest, ExtendConversions) {
  const char* program =
      R"(fn main(x: u8, y: s8) -> (u32, u32, s32, s32) {
  (x as u32, y as u32, x as s32, y as s32)
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__main(x: bits[8], y: bits[8]) -> (bits[32], bits[32], bits[32], bits[32]) {
  zero_ext.3: bits[32] = zero_ext(x, new_bit_count=32, id=3)
  sign_ext.4: bits[32] = sign_ext(y, new_bit_count=32, id=4)
  zero_ext.5: bits[32] = zero_ext(x, new_bit_count=32, id=5)
  sign_ext.6: bits[32] = sign_ext(y, new_bit_count=32, id=6)
  ret tuple.7: (bits[32], bits[32], bits[32], bits[32]) = tuple(zero_ext.3, sign_ext.4, zero_ext.5, sign_ext.6, id=7)
}
)");
}

TEST(IrConverterTest, TupleIndex) {
  const char* program =
      R"(fn main() -> u8 {
  let t = (u32:3, u8:4);
  t[1]
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__main() -> bits[8] {
  literal.1: bits[32] = literal(value=3, id=1)
  literal.2: bits[8] = literal(value=4, id=2)
  t: (bits[32], bits[8]) = tuple(literal.1, literal.2, id=3)
  literal.4: bits[32] = literal(value=1, id=4)
  ret tuple_index.5: bits[8] = tuple_index(t, index=1, id=5)
}
)");
}

TEST(IrConverterTest, BasicStruct) {
  const char* program =
      R"(
struct Point {
  x: u32,
  y: u32,
}

fn f(xy: u32) -> Point {
  Point { x: xy, y: xy }
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f(xy: bits[32]) -> (bits[32], bits[32]) {
  ret tuple.2: (bits[32], bits[32]) = tuple(xy, xy, id=2)
}
)");
}

TEST(IrConverterTest, InvokeNullary) {
  const char* program =
      R"(fn callee() -> u32 {
  u32:42
}
fn caller() -> u32 {
  callee()
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/true));
  ExpectIr(converted, TestName());
}

TEST(IrConverterTest, Match) {
  const char* program =
      R"(
fn f(x: u8) -> u2 {
  match x {
    u8:42 => u2:0,
    u8:64 => u2:1,
    _ => u2:2
  }
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f(x: bits[8]) -> bits[2] {
  literal.7: bits[8] = literal(value=64, id=7)
  literal.4: bits[8] = literal(value=42, id=4)
  eq.8: bits[1] = eq(literal.7, x, id=8)
  eq.5: bits[1] = eq(literal.4, x, id=5)
  concat.10: bits[2] = concat(eq.8, eq.5, id=10)
  one_hot.11: bits[3] = one_hot(concat.10, lsb_prio=true, id=11)
  literal.6: bits[2] = literal(value=0, id=6)
  literal.9: bits[2] = literal(value=1, id=9)
  literal.3: bits[2] = literal(value=2, id=3)
  literal.2: bits[1] = literal(value=1, id=2)
  ret one_hot_sel.12: bits[2] = one_hot_sel(one_hot.11, cases=[literal.6, literal.9, literal.3], id=12)
}
)");
}

TEST(IrConverterTest, MatchDense) {
  const char* program =
      R"(
fn f(x: u2) -> u8 {
  match x {
    u2:0 => u8:42,
    u2:1 => u8:64,
    u2:2 => u8:128,
    _ => u8:255
  }
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f(x: bits[2]) -> bits[8] {
  literal.10: bits[2] = literal(value=2, id=10)
  literal.7: bits[2] = literal(value=1, id=7)
  literal.4: bits[2] = literal(value=0, id=4)
  eq.11: bits[1] = eq(literal.10, x, id=11)
  eq.8: bits[1] = eq(literal.7, x, id=8)
  eq.5: bits[1] = eq(literal.4, x, id=5)
  concat.13: bits[3] = concat(eq.11, eq.8, eq.5, id=13)
  one_hot.14: bits[4] = one_hot(concat.13, lsb_prio=true, id=14)
  literal.6: bits[8] = literal(value=42, id=6)
  literal.9: bits[8] = literal(value=64, id=9)
  literal.12: bits[8] = literal(value=128, id=12)
  literal.3: bits[8] = literal(value=255, id=3)
  literal.2: bits[1] = literal(value=1, id=2)
  ret one_hot_sel.15: bits[8] = one_hot_sel(one_hot.14, cases=[literal.6, literal.9, literal.12, literal.3], id=15)
}
)");
}

TEST(IrConverterTest, EnumUse) {
  const char* program =
      R"(
enum Foo : u32 {
  THING = 0,
  OTHER = 1,
}
fn f(x: Foo) -> Foo {
  Foo::OTHER if x == Foo::THING else Foo::THING
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f(x: bits[32]) -> bits[32] {
  literal.2: bits[32] = literal(value=0, id=2)
  eq.3: bits[1] = eq(x, literal.2, id=3)
  literal.5: bits[32] = literal(value=0, id=5)
  literal.4: bits[32] = literal(value=1, id=4)
  ret sel.6: bits[32] = sel(eq.3, cases=[literal.5, literal.4], id=6)
}
)");
}

TEST(IrConverterTest, ArrayEllipsis) {
  const char* program =
      R"(
fn main() -> u8[2] {
  u8[2]:[0, ...]
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  ExpectIr(converted, TestName());
}

TEST(IrConverterTest, NonConstArrayEllipsis) {
  const char* program =
      R"(
fn main(x: bits[8]) -> u8[4] {
  u8[4]:[u8:0, x, ...]
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__main(x: bits[8]) -> bits[8][4] {
  literal.2: bits[8] = literal(value=0, id=2)
  ret array.3: bits[8][4] = array(literal.2, x, x, x, id=3)
}
)");
}

TEST(IrConverterTest, ArrayUpdate) {
  const char* program =
      R"(
fn main(input: u8[2]) -> u8[2] {
  update(input, u32:1, u8:0x42)
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__main(input: bits[8][2]) -> bits[8][2] {
  literal.3: bits[8] = literal(value=66, id=3)
  literal.2: bits[32] = literal(value=1, id=2)
  ret array_update.4: bits[8][2] = array_update(input, literal.3, indices=[literal.2], id=4)
}
)");
}

TEST(IrConverterTest, SplatStructInstance) {
  const char* program =
      R"(
struct Point {
  x: u32,
  y: u32,
}

fn f(p: Point, new_y: u32) -> Point {
  Point { y: new_y, ..p }
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f(p: (bits[32], bits[32]), new_y: bits[32]) -> (bits[32], bits[32]) {
  tuple_index.3: bits[32] = tuple_index(p, index=0, id=3)
  ret tuple.4: (bits[32], bits[32]) = tuple(tuple_index.3, new_y, id=4)
}
)");
}

TEST(IrConverterTest, BoolLiterals) {
  const char* program =
      R"(
fn f(x: u8) -> bool {
  true if x == u8:42 else false
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f(x: bits[8]) -> bits[1] {
  literal.2: bits[8] = literal(value=42, id=2)
  eq.3: bits[1] = eq(x, literal.2, id=3)
  literal.5: bits[1] = literal(value=0, id=5)
  literal.4: bits[1] = literal(value=1, id=4)
  ret sel.6: bits[1] = sel(eq.3, cases=[literal.5, literal.4], id=6)
}
)");
}

TEST(IrConverterTest, MatchIdentity) {
  const char* program =
      R"(
fn f(x: u8) -> u2 {
  match x {
    u8:42 => u2:3,
    _ => x as u2
  }
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f(x: bits[8]) -> bits[2] {
  literal.4: bits[8] = literal(value=42, id=4)
  eq.5: bits[1] = eq(literal.4, x, id=5)
  concat.7: bits[1] = concat(eq.5, id=7)
  one_hot.8: bits[2] = one_hot(concat.7, lsb_prio=true, id=8)
  literal.6: bits[2] = literal(value=3, id=6)
  bit_slice.3: bits[2] = bit_slice(x, start=0, width=2, id=3)
  literal.2: bits[1] = literal(value=1, id=2)
  ret one_hot_sel.9: bits[2] = one_hot_sel(one_hot.8, cases=[literal.6, bit_slice.3], id=9)
}
)");
}

TEST(IrConverterTest, Ternary) {
  const char* program =
      R"(fn main(x: bool) -> u8 {
  u8:42 if x else u8:24
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/true));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__main(x: bits[1]) -> bits[8] {
  literal.3: bits[8] = literal(value=24, id=3, pos=0,1,21)
  literal.2: bits[8] = literal(value=42, id=2, pos=0,1,5)
  ret sel.4: bits[8] = sel(x, cases=[literal.3, literal.2], id=4, pos=0,1,8)
}
)");
}

TEST(IrConverterTest, MatchPackageLevelConstant) {
  const char* program =
      R"(const FOO = u8:0xff;
fn f(x: u8) -> u2 {
  match x {
    FOO => u2:0,
    _ => x as u2
  }
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f(x: bits[8]) -> bits[2] {
  literal.2: bits[8] = literal(value=255, id=2)
  eq.5: bits[1] = eq(literal.2, x, id=5)
  concat.7: bits[1] = concat(eq.5, id=7)
  one_hot.8: bits[2] = one_hot(concat.7, lsb_prio=true, id=8)
  literal.6: bits[2] = literal(value=0, id=6)
  bit_slice.4: bits[2] = bit_slice(x, start=0, width=2, id=4)
  literal.3: bits[1] = literal(value=1, id=3)
  ret one_hot_sel.9: bits[2] = one_hot_sel(one_hot.8, cases=[literal.6, bit_slice.4], id=9)
}
)");
}

TEST(IrConverterTest, ParametricInvocation) {
  const char* program =
      R"(
fn parametric_id<N: u32>(x: bits[N]) -> bits[N] {
  x+(N as bits[N])
}

fn main(x: u8) -> u8 {
  parametric_id(x)
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__parametric_id__8(x: bits[8]) -> bits[8] {
  literal.2: bits[32] = literal(value=8, id=2)
  bit_slice.3: bits[8] = bit_slice(literal.2, start=0, width=8, id=3)
  ret add.4: bits[8] = add(x, bit_slice.3, id=4)
}

fn __test_module__main(x: bits[8]) -> bits[8] {
  ret invoke.6: bits[8] = invoke(x, to_apply=__test_module__parametric_id__8, id=6)
}
)");
}

TEST(IrConverterTest, MatchUnderLet) {
  const char* program =
      R"(
fn main(x: u8) -> u8 {
  let t = match x {
    u8:42 => u8:0xff,
    _ => x
  };
  t
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__main(x: bits[8]) -> bits[8] {
  literal.3: bits[8] = literal(value=42, id=3)
  eq.4: bits[1] = eq(literal.3, x, id=4)
  concat.6: bits[1] = concat(eq.4, id=6)
  one_hot.7: bits[2] = one_hot(concat.6, lsb_prio=true, id=7)
  literal.5: bits[8] = literal(value=255, id=5)
  literal.2: bits[1] = literal(value=1, id=2)
  ret t: bits[8] = one_hot_sel(one_hot.7, cases=[literal.5, x], id=8)
}
)");
}

TEST(IrConverterTest, WidthSlice) {
  const char* program =
      R"(
fn f(x: u32, y: u32) -> u8 {
  x[2+:u8]+x[y+:u8]
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f(x: bits[32], y: bits[32]) -> bits[8] {
  literal.3: bits[32] = literal(value=2, id=3)
  dynamic_bit_slice.4: bits[8] = dynamic_bit_slice(x, literal.3, width=8, id=4)
  dynamic_bit_slice.5: bits[8] = dynamic_bit_slice(x, y, width=8, id=5)
  ret add.6: bits[8] = add(dynamic_bit_slice.4, dynamic_bit_slice.5, id=6)
}
)");
}

TEST(IrConverterTest, SingleElementBitsArrayParam) {
  const char* program =
      R"(
fn f(x: u32[1]) -> u32[1] {
  x
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f(x: bits[32][1]) -> bits[32][1] {
  ret identity.2: bits[32][1] = identity(x, id=2)
}
)");
}

TEST(IrConverterTest, SingleElementEnumArrayParam) {
  const char* program =
      R"(
enum Foo : u2 {}
fn f(x: Foo[1]) -> Foo[1] {
  x
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f(x: bits[2][1]) -> bits[2][1] {
  ret identity.2: bits[2][1] = identity(x, id=2)
}
)");
}

TEST(IrConverterTest, BitSliceCast) {
  const char* program =
      R"(
fn main(x: u2) -> u1 {
  x as u1
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__main(x: bits[2]) -> bits[1] {
  ret bit_slice.2: bits[1] = bit_slice(x, start=0, width=1, id=2)
}
)");
}

TEST(IrConverterTest, MatchDenseConsts) {
  const char* program =
      R"(
type MyU2 = u2;
const ZERO = MyU2:0;
const ONE = MyU2:1;
const TWO = MyU2:2;
fn f(x: u2) -> u8 {
  match x {
    ZERO => u8:42,
    ONE => u8:64,
    TWO => u8:128,
    _ => u8:255
  }
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f(x: bits[2]) -> bits[8] {
  literal.3: bits[2] = literal(value=2, id=3)
  literal.2: bits[2] = literal(value=1, id=2)
  literal.4: bits[2] = literal(value=0, id=4)
  eq.11: bits[1] = eq(literal.3, x, id=11)
  eq.9: bits[1] = eq(literal.2, x, id=9)
  eq.7: bits[1] = eq(literal.4, x, id=7)
  concat.13: bits[3] = concat(eq.11, eq.9, eq.7, id=13)
  one_hot.14: bits[4] = one_hot(concat.13, lsb_prio=true, id=14)
  literal.8: bits[8] = literal(value=42, id=8)
  literal.10: bits[8] = literal(value=64, id=10)
  literal.12: bits[8] = literal(value=128, id=12)
  literal.6: bits[8] = literal(value=255, id=6)
  literal.5: bits[1] = literal(value=1, id=5)
  ret one_hot_sel.15: bits[8] = one_hot_sel(one_hot.14, cases=[literal.8, literal.10, literal.12, literal.6], id=15)
}
)");
}

TEST(IrConverterTest, CountedForWithLoopInvariants) {
  const char* program =
      R"(
fn f() -> u32 {
  let outer_thing: u32 = u32:42;
  let other_outer_thing: u32 = u32:24;
  for (i, accum): (u32, u32) in range(u32:0, u32:4) {
    accum + i + outer_thing + other_outer_thing
  }(u32:0)
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn ____test_module__f_counted_for_0_body(i: bits[32], accum: bits[32], other_outer_thing: bits[32], outer_thing: bits[32]) -> bits[32] {
  add.10: bits[32] = add(accum, i, id=10)
  add.11: bits[32] = add(add.10, outer_thing, id=11)
  ret add.12: bits[32] = add(add.11, other_outer_thing, id=12)
}

fn __test_module__f() -> bits[32] {
  literal.3: bits[32] = literal(value=0, id=3)
  literal.2: bits[32] = literal(value=24, id=2)
  literal.1: bits[32] = literal(value=42, id=1)
  literal.4: bits[32] = literal(value=0, id=4)
  literal.5: bits[32] = literal(value=4, id=5)
  ret counted_for.13: bits[32] = counted_for(literal.3, trip_count=4, stride=1, body=____test_module__f_counted_for_0_body, invariant_args=[literal.2, literal.1], id=13)
}
)");
}

TEST(IrConverterTest, CountedForWithTupleAccumulator) {
  const char* program =
      R"(
fn f() -> (u32, u32) {
  for (i, (a, b)): (u32, (u32, u32)) in range(u32:0, u32:4) {
    (a+b, b+u32:1)
  }((u32:0, u32:1))
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn ____test_module__f_counted_for_0_body(i: bits[32], __loop_carry: (bits[32], bits[32])) -> (bits[32], bits[32]) {
  literal.8: bits[1] = literal(value=1, id=8)
  literal.10: bits[1] = literal(value=1, id=10)
  tuple_index.9: bits[32] = tuple_index(__loop_carry, index=0, id=9)
  tuple_index.12: bits[32] = tuple_index(__loop_carry, index=1, id=12)
  literal.16: bits[32] = literal(value=1, id=16)
  and.11: bits[1] = and(literal.8, literal.10, id=11)
  literal.13: bits[1] = literal(value=1, id=13)
  add.15: bits[32] = add(tuple_index.9, tuple_index.12, id=15)
  add.17: bits[32] = add(tuple_index.12, literal.16, id=17)
  and.14: bits[1] = and(and.11, literal.13, id=14)
  ret tuple.18: (bits[32], bits[32]) = tuple(add.15, add.17, id=18)
}

fn __test_module__f() -> (bits[32], bits[32]) {
  literal.1: bits[32] = literal(value=0, id=1)
  literal.2: bits[32] = literal(value=1, id=2)
  tuple.3: (bits[32], bits[32]) = tuple(literal.1, literal.2, id=3)
  literal.4: bits[32] = literal(value=0, id=4)
  literal.5: bits[32] = literal(value=4, id=5)
  ret counted_for.19: (bits[32], bits[32]) = counted_for(tuple.3, trip_count=4, stride=1, body=____test_module__f_counted_for_0_body, id=19)
}
)");
}

TEST(IrConverterTest, InvokeMultipleArgs) {
  const char* program =
      R"(fn callee(x: bits[32], y: bits[32]) -> bits[32] {
  x + y
}
fn caller() -> u32 {
  callee(u32:2, u32:3)
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/true));
  ExpectIr(converted, TestName());
}

TEST(IrConverterTest, CastOfAdd) {
  const char* program =
      R"(
fn main(x: u8, y: u8) -> u32 {
  (x + y) as u32
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__main(x: bits[8], y: bits[8]) -> bits[32] {
  add.3: bits[8] = add(x, y, id=3)
  ret zero_ext.4: bits[32] = zero_ext(add.3, new_bit_count=32, id=4)
}
)");
}

TEST(IrConverterTest, IdentityFinalArg) {
  const char* program =
      R"(
fn main(x0: u19, x3: u29) -> u29 {
  let x15: u29 = u29:0;
  let x17: u19 = (x0) + (x15 as u19);
  x3
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__main(x0: bits[19], x3: bits[29]) -> bits[29] {
  literal.3: bits[29] = literal(value=0, id=3)
  bit_slice.4: bits[19] = bit_slice(literal.3, start=0, width=19, id=4)
  x17: bits[19] = add(x0, bit_slice.4, id=5)
  ret identity.6: bits[29] = identity(x3, id=6)
}
)");
}

TEST(IrConverterTest, ModuleLevelConstantDims) {
  const char* program =
      R"(
const BATCH_SIZE = u32:17;

fn main(x: u32[BATCH_SIZE]) -> u32 {
  x[u32:16]
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__main(x: bits[32][17]) -> bits[32] {
  literal.2: bits[32] = literal(value=16, id=2)
  ret array_index.3: bits[32] = array_index(x, indices=[literal.2], id=3)
}
)");
}

TEST(IrConverterTest, SignedComparisons) {
  const char* program =
      R"(
fn main(x: u32, y: u32) -> bool {
  sgt(x, y) && slt(x, y) && sge(x, y) && sle(x, y)
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__main(x: bits[32], y: bits[32]) -> bits[1] {
  sgt.3: bits[1] = sgt(x, y, id=3)
  slt.4: bits[1] = slt(x, y, id=4)
  and.5: bits[1] = and(sgt.3, slt.4, id=5)
  sge.6: bits[1] = sge(x, y, id=6)
  and.7: bits[1] = and(and.5, sge.6, id=7)
  sle.8: bits[1] = sle(x, y, id=8)
  ret and.9: bits[1] = and(and.7, sle.8, id=9)
}
)");
}

TEST(IrConverterTest, Signex) {
  const char* program =
      R"(
fn main(x: u8) -> u32 {
  signex(x, u32:0)
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__main(x: bits[8]) -> bits[32] {
  literal.2: bits[32] = literal(value=0, id=2)
  ret sign_ext.3: bits[32] = sign_ext(x, new_bit_count=32, id=3)
}
)");
}

TEST(IrConverterTest, OneHotSelSplatVariadic) {
  const char* program =
      R"(
fn main(s: u2) -> u32 {
  one_hot_sel(s, u32[2]:[2, 3])
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  ExpectIr(converted, TestName());
}

TEST(IrConverterTest, BitSliceSyntax) {
  const char* program =
      R"(
fn f(x: u4) -> u2 {
  x[:2]+x[-2:]+x[1:3]+x[-3:-1]+x[0:-2]
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f(x: bits[4]) -> bits[2] {
  bit_slice.2: bits[2] = bit_slice(x, start=0, width=2, id=2)
  bit_slice.3: bits[2] = bit_slice(x, start=2, width=2, id=3)
  add.4: bits[2] = add(bit_slice.2, bit_slice.3, id=4)
  bit_slice.5: bits[2] = bit_slice(x, start=1, width=2, id=5)
  add.6: bits[2] = add(add.4, bit_slice.5, id=6)
  bit_slice.7: bits[2] = bit_slice(x, start=1, width=2, id=7)
  add.8: bits[2] = add(add.6, bit_slice.7, id=8)
  bit_slice.9: bits[2] = bit_slice(x, start=0, width=2, id=9)
  ret add.10: bits[2] = add(add.8, bit_slice.9, id=10)
}
)");
}

TEST(IrConverterTest, InvocationMultiSymbol) {
  const char* program =
      R"(fn parametric<M: u32, N: u32, R: u32 = M + N>(x: bits[M], y: bits[N]) -> bits[R] {
  x ++ y
}
fn main() -> u8 {
  parametric(bits[3]:0, bits[5]:1)
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/true));
  ExpectIr(converted, TestName());
}

TEST(IrConverterTest, ArrayConcat0) {
  const char* program =
      R"(
fn f(in1: u32[2]) -> u32 {
  let x : u32[4] = in1 ++ in1;
  x[u32:0]
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f(in1: bits[32][2]) -> bits[32] {
  x: bits[32][4] = array_concat(in1, in1, id=2)
  literal.3: bits[32] = literal(value=0, id=3)
  ret array_index.4: bits[32] = array_index(x, indices=[literal.3], id=4)
}
)");
}

TEST(IrConverterTest, PackageLevelConstantArray) {
  const char* program =
      R"(const FOO = u8[2]:[1, 2];
fn f() -> u8[2] { FOO }
fn g() -> u8[2] { FOO }
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/true));
  ExpectIr(converted, TestName());
}

TEST(IrConverterTest, MatchWithlet) {
  const char* program =
      R"(
fn f(x: u8) -> u2 {
  match x {
    u8:42 => let x = u2:0; x,
    u8:64 => let x = u2:1; x,
    _ => let x = u2:2; x
  }
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__f(x: bits[8]) -> bits[2] {
  literal.7: bits[8] = literal(value=64, id=7)
  literal.4: bits[8] = literal(value=42, id=4)
  eq.8: bits[1] = eq(literal.7, x, id=8)
  eq.5: bits[1] = eq(literal.4, x, id=5)
  concat.10: bits[2] = concat(eq.8, eq.5, id=10)
  one_hot.11: bits[3] = one_hot(concat.10, lsb_prio=true, id=11)
  literal.6: bits[2] = literal(value=0, id=6)
  literal.9: bits[2] = literal(value=1, id=9)
  literal.3: bits[2] = literal(value=2, id=3)
  literal.2: bits[1] = literal(value=1, id=2)
  ret one_hot_sel.12: bits[2] = one_hot_sel(one_hot.11, cases=[literal.6, literal.9, literal.3], id=12)
}
)");
}

TEST(IrConverterTest, SignexAcceptsSignedOutputType) {
  const char* program =
      R"(
fn main(x: u8) -> s32 {
  signex(x, s32:0)
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__main(x: bits[8]) -> bits[32] {
  literal.2: bits[32] = literal(value=0, id=2)
  ret sign_ext.3: bits[32] = sign_ext(x, new_bit_count=32, id=3)
}
)");
}

TEST(IrConverterTest, StructWithConstSizedArray) {
  const char* program =
      R"(
const THING_COUNT = u32:2;
type Foo = (
  u32[THING_COUNT]
);
fn get_thing(x: Foo, i: u32) -> u32 {
  let things: u32[THING_COUNT] = x[0];
  things[i]
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__get_thing(x: (bits[32][2]), i: bits[32]) -> bits[32] {
  things: bits[32][2] = tuple_index(x, index=0, id=4)
  literal.3: bits[32] = literal(value=0, id=3)
  ret array_index.5: bits[32] = array_index(things, indices=[i], id=5)
}
)");
}

// Tests that a simple constexpr function can be evaluated at compile time
// (which we observe at IR conversion time).
TEST(IrConverterTest, ConstexprFunction) {
  const char* program =
      R"(
const MY_CONST = u32:5;
fn constexpr_fn(arg: u32) -> u32 {
  arg * MY_CONST
}

fn f() -> u32 {
  let x = constexpr_fn(MY_CONST);
  x
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  ExpectIr(converted, TestName());
}

TEST(IrConverterTest, NestedTupleSignature) {
  const char* program =
      R"(
    type Foo = u3;

    type MyTup = (u6, u1);

    type TupOfThings = (u1, MyTup, Foo);

    type MoreStructured = (
      TupOfThings[3],
      u3,
      u1,
    );

    type Data = (u64, u1);

    fn main(r: u9, l: u10, input: MoreStructured) -> (u9, u10, Data) {
      (u9:0, u10:0, (u64:0, u1:0))
    }
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__main(r: bits[9], l: bits[10], input: ((bits[1], (bits[6], bits[1]), bits[3])[3], bits[3], bits[1])) -> (bits[9], bits[10], (bits[64], bits[1])) {
  literal.6: bits[64] = literal(value=0, id=6)
  literal.7: bits[1] = literal(value=0, id=7)
  literal.4: bits[9] = literal(value=0, id=4)
  literal.5: bits[10] = literal(value=0, id=5)
  tuple.8: (bits[64], bits[1]) = tuple(literal.6, literal.7, id=8)
  ret tuple.9: (bits[9], bits[10], (bits[64], bits[1])) = tuple(literal.4, literal.5, tuple.8, id=9)
}
)");
}

TEST(IrConverterTest, ArrayUpdateInLoop) {
  const char* program =
      R"(
fn main() -> u8[2] {
  for (i, accum): (u32, u8[2]) in range(u32:0, u32:2) {
    update(accum, i, i as u8)
  }(u8[2]:[0, 0])
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  ExpectIr(converted, TestName());
}

TEST(IrConverterTest, Identity) {
  const char* program =
      R"(fn main(x: u8) -> u8 {
  x
})";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/true));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__main(x: bits[8]) -> bits[8] {
  ret identity.2: bits[8] = identity(x, id=2, pos=0,1,2)
}
)");
}

TEST(IrConverterTest, PackageLevelConstantArrayAccess) {
  const char* program =
      R"(
const FOO = u8[2]:[1, 2];
fn f() -> u8 { FOO[u32:0] }
fn g() -> u8 { FOO[u32:1] }
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  ExpectIr(converted, TestName());
}

TEST(IrConverterTest, TransitiveParametricInvocation) {
  const char* program =
      R"(
fn parametric_id<N: u32>(x: bits[N]) -> bits[N] {
  x+(N as bits[N])
}
fn parametric_id_wrapper<M: u32>(x: bits[M]) -> bits[M] {
  parametric_id(x)
}
fn main(x: u8) -> u8 {
  parametric_id_wrapper(x)
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__parametric_id__8(x: bits[8]) -> bits[8] {
  literal.2: bits[32] = literal(value=8, id=2)
  bit_slice.3: bits[8] = bit_slice(literal.2, start=0, width=8, id=3)
  ret add.4: bits[8] = add(x, bit_slice.3, id=4)
}

fn __test_module__parametric_id_wrapper__8(x: bits[8]) -> bits[8] {
  literal.6: bits[32] = literal(value=8, id=6)
  ret invoke.7: bits[8] = invoke(x, to_apply=__test_module__parametric_id__8, id=7)
}

fn __test_module__main(x: bits[8]) -> bits[8] {
  ret invoke.9: bits[8] = invoke(x, to_apply=__test_module__parametric_id_wrapper__8, id=9)
}
)");
}

TEST(IrConverterTest, ParametricIrConversion) {
  const char* program =
      R"(
fn parametric<N: u32>(x: bits[N]) -> u32 {
  N
}

fn main() -> u32 {
  parametric(bits[2]:0) + parametric(bits[3]:0)
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  ExpectIr(converted, TestName());
}

TEST(IrConverterTest, FailIsElided) {
  const char* program =
      R"(
fn main() -> u32 {
  fail!(u32:42)
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__main() -> bits[32] {
  literal.1: bits[32] = literal(value=42, id=1)
  ret identity.2: bits[32] = identity(literal.1, id=2)
}
)");
}

TEST(IrConverterTest, CountedForParametricRefInBody) {
  const char* program =
      R"(
fn f<N:u32>(init: bits[N]) -> bits[N] {
  for (i, accum): (u32, bits[N]) in range(u32:0, u32:4) {
    accum as bits[N]
  }(init)
}

fn main() -> u32 {
  f(u32:0)
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  ExpectIr(converted, TestName());
}

TEST(IrConverterTest, SignedComparisonsViaSignedNumbers) {
  const char* program =
      R"(
fn main(x: s32, y: s32) -> bool {
  x > y && x < y && x >= y && x <= y
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  EXPECT_EQ(converted, R"(package test_module

fn __test_module__main(x: bits[32], y: bits[32]) -> bits[1] {
  sgt.3: bits[1] = sgt(x, y, id=3)
  slt.4: bits[1] = slt(x, y, id=4)
  and.5: bits[1] = and(sgt.3, slt.4, id=5)
  sge.6: bits[1] = sge(x, y, id=6)
  and.7: bits[1] = and(and.5, sge.6, id=7)
  sle.8: bits[1] = sle(x, y, id=8)
  ret and.9: bits[1] = and(and.7, sle.8, id=9)
}
)");
}

// Tests that a parametric constexpr function can be evaluated at compile time
// (IR conversion time).
TEST(IrConverterTest, ParametricConstexprFn) {
  const char* program =
      R"(
pub const MY_CONST = u32:5;
fn constexpr_fn<N:u32>(arg: bits[N]) -> bits[N] {
  arg * MY_CONST
}

fn f() -> u32 {
  let x = constexpr_fn(MY_CONST);
  x
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  ExpectIr(converted, TestName());
}

TEST(IrConverterTest, ConstexprImport) {
  // Place the *imported* module into the import cache.
  ImportCache import_cache;
  const char* imported_program = R"(
pub const MY_CONST = bits[32]:5;

pub fn constexpr_fn(arg: u32) -> u32 {
  arg * MY_CONST
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      TypecheckedModule tm,
      ParseAndTypecheck(imported_program, "fake/imported/stuff.x",
                        "fake.imported.stuff", &import_cache));
  const char* importer_program = R"(
import fake.imported.stuff

fn f() -> u32 {
  let x = stuff::constexpr_fn(stuff::MY_CONST);
  x
}
)";
  (void)tm;  // Module is in the import cache.

  // Convert the *importer* module to IR.
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(importer_program, /*emit_positions=*/false,
                           &import_cache));
  ExpectIr(converted, TestName());
}

// Tests that a parametric constexpr function can be imported.
TEST(IrConverterTest, ParametricConstexprImport) {
  // Place the *imported* module into the import cache.
  ImportCache import_cache;
  const char* imported_program = R"(
pub const MY_CONST = bits[32]:5;

pub fn constexpr_fn<N:u32>(arg: bits[N]) -> bits[N] {
  arg * MY_CONST
}

)";
  XLS_ASSERT_OK_AND_ASSIGN(
      TypecheckedModule tm,
      ParseAndTypecheck(imported_program, "fake/imported/stuff.x",
                        "fake.imported.stuff", &import_cache));
  const char* importer_program = R"(
import fake.imported.stuff

fn f() -> u32 {
  let x = stuff::constexpr_fn(stuff::MY_CONST);
  x
}
)";
  (void)tm;  // Already placed in import cache.

  // Convert the *importer* module to IR.
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(importer_program, /*emit_positions=*/false,
                           &import_cache));
  ExpectIr(converted, TestName());
}

TEST(IrConverterTest, BitSliceUpdate) {
  const char* program =
      R"(
fn main(x: u32, y: u16, z: u8) -> u32 {
  bit_slice_update(x, y, z)
}
)";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  ExpectIr(converted, TestName());
}

TEST(IrConverterTest, TokenIdentityFunction) {
  absl::string_view program = "fn main(x: token) -> token { x }";
  XLS_ASSERT_OK_AND_ASSIGN(
      std::string converted,
      ConvertModuleForTest(program, /*emit_positions=*/false));
  ExpectIr(converted, TestName());
}

}  // namespace
}  // namespace xls::dslx

int main(int argc, char* argv[]) {
  xls::InitXls(argv[0], argc, argv);
  return RUN_ALL_TESTS();
}
