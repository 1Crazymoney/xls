#include "xls/ir/nodes.h"

#include "xls/common/logging/logging.h"
#include "xls/common/status/ret_check.h"
#include "absl/status/statusor.h"
#include "xls/ir/function.h"
#include "xls/ir/package.h"

namespace xls {

namespace {

Type* GetTupleType(Package* package, absl::Span<Node* const> operands) {
  std::vector<Type*> operand_types;
  for (Node* operand : operands) {
    operand_types.push_back(operand->GetType());
  }
  return package->GetTupleType(operand_types);
}

Type* GetConcatType(Package* package, absl::Span<Node* const> operands) {
  int64 width = 0;
  for (Node* operand : operands) {
    width += operand->BitCountOrDie();
  }
  return package->GetBitsType(width);
}

Type* GetArrayConcatType(Package* package, absl::Span<Node* const> operands) {
  int64 size = 0;
  Type* element_type = nullptr;

  for (Node* operand : operands) {
    auto operand_type = operand->GetType()->AsArrayOrDie();

    size += operand_type->size();
    if (element_type == nullptr) {
      // Set element_type to the first operand's element type
      element_type = operand_type->element_type();
    }
  }

  XLS_CHECK(element_type);
  return package->GetArrayType(size, element_type);
}

Type* GetMapType(Node* operand, Function* to_apply) {
  return operand->package()->GetArrayType(operand->GetType()->AsArrayOrDie()->size(),
                                 to_apply->return_value()->GetType());
}

}  // namespace

{% for op_class in spec.OpClass.kinds.values() -%}
{{ op_class.name }}::{{ op_class.name }} ({{ op_class.constructor_args_str() }}) :
  {{ op_class.base_constructor_invocation() }}
{%- for member in op_class.data_members() -%}
   , {{ member.name }}({{ member.init }})
{%- endfor -%}
{
{% for op in op_class.operands %}
   {{ op.add_method }}({{ op.name }});
{%- endfor %}
}

{% if not op_class.custom_clone_method %}
absl::StatusOr<Node*> {{ op_class.name }}::Clone(absl::Span<Node* const> new_operands,
                                    Function* new_function) const {
  XLS_RET_CHECK_EQ(operand_count(), new_operands.size());
  return new_function->MakeNode<{{ op_class.name }}>({{ op_class.clone_args_str("new_operands") }});
}
{% endif %}

{% if op_class.data_members() %}
bool {{ op_class.name }}::IsDefinitelyEqualTo(const Node* other) const {
  if (!Node::IsDefinitelyEqualTo(other)) {
    return false;
  }

  return {{ op_class.equal_to_expr() }};
}
{% endif %}

{% endfor %}

SliceData Concat::GetOperandSliceData(int64 operandno) const {
  XLS_CHECK_GE(operandno, 0);
  int64 start = 0;
  for (int64 i = operands().size()-1; i > operandno; --i) {
    Node* operand = this->operand(i);
    start += operand->BitCountOrDie();
  }
  return SliceData{start, this->operand(operandno)->BitCountOrDie()};
}

bool CountedFor::IsArrayParallelizable() const {
  Node* index = body()->params().at(0);
  Node* input_accumulator = body()->params().at(1);
  Node* return_value = body()->return_value();

  // Accumulator must be an array to parallelize.
  if(!input_accumulator->GetType()->IsArray()) {
    return false;
  }

  // Only parallelize if each loop iteration updates a
  // single array accumulator index. Note that
  // if a loop iteration updated multiple indexes,
  // there would be a chain of ArrayUpdate nodes
  // such that the returned ArrayUpdate node
  // would not have the input accumulator as input.
  if(return_value->op() != Op::kArrayUpdate 
    || return_value->operands().at(0) != input_accumulator) {
    return false;
  }

  // The loop isn't parallelizable if output
  // from one iteration is consumed in a subsequent 
  // iteration. We could still parallelize the loop 
  // if only inititial accumulator values are consumed 
  // in the loop. However, simply checking if the 
  // accumulator input has users should be  sufficient 
  // for most common cases.
  // Note: One user is allowed - the ArrayUpdate that
  // writes an index in the output array.
  if(input_accumulator->users().size() != 1) {
    return false;
  }
  XLS_CHECK(input_accumulator->users().at(0) == return_value);

  // Check that each iteration writes one unique array index.
  // We cover the common case by simply checking that the
  // each loop trip (0,1,2,...) writes the corresponding
  // array index (0,1,2,...). ArrayUpdate index is the 
  // CountedFor index. If necessary, we could generalize
  // this to cover other valid cases, such as 
  // Array[(index + 4) % ArraySize] = ...
  // In this case, we would probably want to return a mapping
  // from loop iteration to ArrayUpdate index.
  if(return_value->operands().at(1) != index || stride() != 1 || trip_count() != input_accumulator->GetType()->AsArrayOrDie()->size()) {
    return false;
  }

  
  return true;
}

absl::StatusOr<Node*> Send::Clone(absl::Span<Node* const> new_operands,
                                           Function* new_function) const {
  return new_function->MakeNode<Send>(loc(),
                                      new_operands[0],
                                      new_operands.subspan(1),
                                      channel_id());
}

absl::StatusOr<Node*> SendIf::Clone(absl::Span<Node* const> new_operands,
                                           Function* new_function) const {
  return new_function->MakeNode<SendIf>(loc(),
                                        new_operands[0],
                                        new_operands[1],
                                        new_operands.subspan(2),
                                        channel_id());
}

absl::StatusOr<Node*> CountedFor::Clone(absl::Span<Node* const> new_operands,
                                        Function* new_function) const {
  XLS_RET_CHECK_EQ(operand_count(), new_operands.size());
  return new_function->MakeNode<CountedFor>(loc(), new_operands[0],
                                            new_operands.subspan(1),
                                            trip_count(),
                                            stride(),
                                            body());
}

absl::StatusOr<Node*> Select::Clone(absl::Span<Node* const> new_operands,
                                    Function* new_function) const {
  XLS_RET_CHECK_EQ(operand_count(), new_operands.size());
  absl::optional<Node*> new_default_value =
    default_value().has_value()
    ? absl::optional<Node*>(new_operands.back())
    : absl::nullopt;
  return new_function->MakeNode<Select>(loc(), new_operands[0],
                                        new_operands.subspan(1, cases_size_),
                                        new_default_value);
}

absl::StatusOr<Node*> OneHotSelect::Clone(absl::Span<Node* const> new_operands,
                                          Function* new_function) const {
  return new_function->MakeNode<OneHotSelect>(loc(), new_operands[0],
                                        new_operands.subspan(1));
}

bool Select::AllCases(std::function<bool(Node*)> p) const {
  for (Node* case_ : cases()) {
    if (!p(case_)) {
      return false;
    }
  }
  if (default_value().has_value()) {
    if (!p(default_value().value())) {
      return false;
    }
  }
  return true;
}

}  // namespace xls
